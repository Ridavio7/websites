package main

import (
	"fmt"
	"math/rand"
	"sync"
	"time"
)

/*
	Разработать программу, которая будет последовательно отправлять значения в канал,
	а с другой стороны канала — читать. По истечению N секунд программа должна завершаться.
*/

const (
	N = 5 // количество секунд
)

func main() {
	intCh := make(chan int) // создаем канал

	timer := time.NewTimer(N * time.Second) // таймер для выхода из программы

	var wg sync.WaitGroup // wg позволяет определить группу горутин, которые должны выполняться вместе как одна группа
	wg.Add(1)

	// воркер читает
	go func() {
		for {
			// num - значение из канала, а more = false, если канал закрыт
			value, ok := <-intCh
			if ok != false {
				fmt.Printf("Worker get: %d\n", value) // если канал открыт, то выполняется работа
			} else {
				fmt.Printf("Workers is done \n") // если канал закрыт, то работа завершается
				wg.Done()
				return
			}
		}
	}()

	// постоянная запись данных в канал (главный поток)
	// метка способствет выходу из цикла
L:
	for {
		select {
		case <-timer.C: //блокирует канал таймера C пока не будет отправлено сообщение о том, что таймер истек
			fmt.Printf("End...\n")
			close(intCh) // закрываем канал
			break L      // завершаем работу цикла после выполнения кейса

		// если таймер еще не сработал - посылаем в канал данные
		default:
			intCh <- rand.Intn(1000) // посылаем рандомное число
			time.Sleep(time.Second)
		}
	}

	wg.Wait()
}
