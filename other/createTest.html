<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.0/css/bootstrap.min.css"
    integrity="sha384-9aIt2nRpC12Uk9gS9baDl411NQApFmC26EwAOH8WgZl5MYYxFfc+NcPb1dKGj7Sk" crossorigin="anonymous">
</head>
<body>
  <div class="container">
    <h3>Create Test</h3>
    <form id="questions-box">
        <!-- контейнер для вопросов -->
        <div class="question-box">
            <br><hr>
            <h4 class="title"></h4>
            <!-- вопрос -->
            <div class="row">
                <input type="text" class="form-control col-11 question-text" value="first question" >
                <!-- кнопка для удаления вопроса-->
                <button class="btn btn-danger col remove-question-btn">X</button>
            </div>
            <hr>

            <h4>Answers:</h4>
            <!-- варианты ответов -->
            <div class="row answers-box">
                <!-- первый вариант -->
                <div class="input-group">
                    <div class="input-group-prepend">
                        <div class="input-group-text">
                            <input type="radio" checked name="answer">
                        </div>
                    </div>

                    <input class="form-control answer-text" type="text" value="foo" >

                    <!-- кнопка для удаления варианта -->
                    <div class="input-group-append">
                        <button class="btn btn-outline-danger remove-answer-btn">X</button>
                    </div>
                </div>
                <!-- второй вариант -->
                <div class="input-group">
                    <div class="input-group-prepend">
                        <div class="input-group-text">
                            <input type="radio" name="answer">
                        </div>
                    </div>

                    <input class="form-control answer-text" type="text" value="bar" >

                    <div class="input-group-append">
                        <button class="btn btn-outline-danger remove-answer-btn">X</button>
                    </div>
                </div>
                <!-- третий вариант -->
                <div class="input-group">
                    <div class="input-group-prepend">
                        <div class="input-group-text">
                            <input type="radio" name="answer">
                        </div>
                    </div>

                    <input class="form-control answer-text" type="text" value="baz" >

                    <div class="input-group-append">
                        <button class="btn btn-outline-danger remove-answer-btn">X</button>
                    </div>
                </div>
            </div>
            <br>

            <!-- кнопка для добавления варианта ответа -->
            <button class="btn btn-primary add-answer-btn">Add answer</button>
            <hr>

            <h4>Explanation:</h4>
            <!-- объяснение -->
            <div class="row explanation-box">
                <input type="text" value="first explanation" class="form-control explanation-text" >
            </div>
        </div>
    </form>

    <br>

    <!-- кнопки для добавления вопроса и создания теста -->
    <button class="btn btn-primary" id="add-question-btn">Add question</button>
    <button class="btn btn-primary" id="create-test-btn">Create test</button>
</div>
      <script>
        // функция нахождения одного элемента с указанным селектором
        const findOne = (element, selector) => element.querySelector(selector)
        // функция нахождения всех элементов с указанным селектором
        const findAll = (element, selector) => element.querySelectorAll(selector)
        // функция добавления обработчика указанного события
        const addHandler = (element, event, callback) => element.addEventListener(event, callback)

        // функция нахождения родительских элементов
        // одной из проблем Bootstrap является глубокая вложенность элементов,
        // при работе с DOM часто возникает необходимость обращения к родителю целевого элемента
        // наша функция принимает два аргумента - элемент и глубину (вложенности),
        // которая по умолчанию равняется 1
        const findParent = (element, depth = 1) => {
            // если элемент находится на первом уровне вложенности,
            // значит, нам нужен его родительский элемент
            let parentEl = element.parentElement

            // иначе, мы ищем родителя родителя и т.д. с помощью рекурсии
            while (depth > 1) {
                // рекурсия
                parentEl = findParent(parentEl)
                // уменьшаем значение глубины
                depth--
            }

            // возвращаем искомый элемент
            return parentEl
        }

const C = findOne(document.body, ".container");
const Q = findOne(C, "#questions-box");

addHandler(Q, "submit", (ev) => ev.preventDefault());

// функция принимает вопрос в качестве аргумента
const initRemoveQuestionBtn = q => {
    const removeQuestionBtn = findOne(q, '.remove-question-btn')

    addHandler(removeQuestionBtn, 'click', ev => {
        // удаляем родителя родителя кнопки
        /*
        =>  <div class="question-box">
                <br><hr>
                <h4 class="title"></h4>
            =>  <div class="row">
                    <input type="text" class="form-control col-11 question-text" value="first question" >
                =>  <button class="btn btn-danger col remove-question-btn">X</button>
                </div>

                ...
        */
        findParent(ev.target, 2).remove()
        // ev.target.parentElement.parentElement.remove()

        // при удалении вопроса необходимо обновить номера вопросов
        initTitles()
    }, {
        // удаляем обработчик после использования
        once: true
    })
}
// Функция инициализации кнопок для удаления варианта ответа:
const initRemoveAnswerBtns = (q) => {
  const removeAnswerBtns = findAll(q, ".remove-answer-btn");

  removeAnswerBtns.forEach((btn) =>
    addHandler(
      btn,
      "click",
      (ev) => {
        findParent(ev.target, 2).remove();
      },
      {
        once: true
      }
    )
  );
};

const initAddAnswerBtns = q => {
    const addAnswerBtns = findAll(q, '.add-answer-btn')

    addAnswerBtns.forEach(btn => addHandler(btn, 'click', ev => {
        // находим контейнер для ответов
        const answers = findOne(findParent(ev.target), '.answers-box')
        // const answers = ev.target.parentElement.querySelector('.answers-box')

        // атрибут "name" должен быть уникальным для каждого вопроса
        let name
        answers.children.length > 0
            ? name = findOne(answers, 'input[type="radio"]').name
            : name = Date.now()

        // шаблон варианта ответа
        const template = `
                <div class="input-group">
                    <div class="input-group-prepend">
                        <div class="input-group-text">
                            <input type="radio" name="${name}">
                        </div>
                    </div>

                    <input class="form-control answer-text" type="text" value="">

                    <div class="input-group-append">
                        <button class="btn btn-outline-danger remove-answer-btn">X</button>
                    </div>
                </div>
                `
        // помещаем шаблон в конец контейнера для ответов
        answers.insertAdjacentHTML('beforeend', template)
        
        // инициализируем кнопки для удаления вариантов ответа
        initRemoveAnswerBtns(q)
    }))
}

const initBtns = (q) => {
  initRemoveQuestionBtn(q);
  initRemoveAnswerBtns(q);
  initAddAnswerBtns(q);
};

// Функция инициализации заголовков вопросов:
const initTitles = () => {
    // преобразуем коллекцию в массив с целью дальнейшего определения номера вопроса
    const questions = Array.from(findAll(Q, '.question-box'))

    // перебираем массив
    questions.map(q => {
        const title = findOne(q, '.title')
        // номер вопроса - это индекс элемента + 1
        title.textContent = `Question ${questions.indexOf(q) + 1}`
    })
}

initBtns(findOne(Q, ".question-box"));

initTitles();

//Функция добавления вопроса:

// находим кнопку
const addQuestionBtn = findOne(C, '#add-question-btn')

addHandler(addQuestionBtn, 'click', ev => {
    // с помощью IIFE и async..await получаем данные посредством динамического импорта
    // помещаем их в контейнер для вопросов
    // находим добавленный вопрос
    // и инициализируем кнопки этого вопроса и все заголовки
    (async () => {
        const data = await import('./Question.js')
        const template = await data.default()
        await Q.insertAdjacentHTML('beforeend', template)

        const question = findOne(Q, '.question-box:last-child')
        initBtns(question)
        initTitles()
    })()
})

addHandler(findOne(C, "#create-test-btn"), "click", () => createTest());

const createTest = () => {
  const obj = {};

  const questions = Array.from(findAll(Q, ".question-box"));

  const isEmpty = (...args) => {
    args.map((arg) => {
      arg = arg.replace(/\s+/g, "").trim();
      if (arg === "") {
        alert("Some field is empty!");
        throw new Error();
      }
    });
  };

  questions.forEach((q) => {
    const questionText = findOne(q, ".question-text").value;

    const answersText = [];
    findAll(q, ".answer-text").forEach((text) => answersText.push(text.value));

    const rightAnswerText = findOne(
      findParent(findOne(q, "input:checked"), 3),
      ".answer-text"
    ).value;

    const explanationText = findOne(q, ".explanation-text").value;

    isEmpty(questionText, ...answersText, explanationText);

    obj[questions.indexOf(q)] = {
      question: questionText,
      answers: answersText,
      rightAnswer: rightAnswerText,
      explanation: explanationText
    };
  });

  console.table(obj);

  const data = new Blob([JSON.stringify(obj)], {
    type: "application/json"
  });

  if (findOne(C, "a") !== null) {
    findOne(C, "a").remove();
  }

  const link = document.createElement("a");
  link.setAttribute("href", URL.createObjectURL(data));
  link.setAttribute("download", "data.json");
  link.className = "btn btn-success";
  link.textContent = "Download data";
  C.append(link);
  URL.revokeObjectURL(data);
};

      </script>
</body>
</html>